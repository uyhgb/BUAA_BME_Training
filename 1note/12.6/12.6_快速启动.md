# exo_sensors IMU CSV数据采集系统 - 快速启动指南

**日期**: 2025年12月6日  
**状态**: ✅ 已验证可用

---

## 🚀 快速启动（3步）

### 步骤1: 连接ESP32到WSL (Windows PowerShell管理员)
```powershell
usbipd list                                  # 查看设备，找到CP2102N
usbipd attach --wsl --busid <BUSID>        # 连接到WSL (如 1-4)
```

### 步骤2: 验证串口连接 (WSL/Docker)
```bash
/workspace/robot_ws/check_esp32_serial.sh   # 应显示 /dev/ttyUSB0
timeout 3 cat /dev/ttyUSB0                  # 查看CSV数据流
```

### 步骤3: 启动ROS2节点
```bash
cd /workspace/robot_ws
source /opt/ros/humble/setup.bash
source install/setup.bash
ros2 launch exo_sensors imu_csv_dev_wsl.launch.py

# 如果在树莓派环境下需配置的映射
ros2 launch exo_sensors imu_csv_raspberry_pi.launch.py
```

**期望输出**:
```
[INFO] [imu_csv_reader]: 串口已打开: /dev/ttyUSB0 @ 115200bps
[INFO] [imu_csv_reader]: [统计] 成功: 100 包/秒 | 姿态: R=5.8° P=-2.5° Y=-94.0°
```

---

## 📊 验证测试

### 测试IMU数据接收
```bash
cd /workspace/robot_ws && source /opt/ros/humble/setup.bash && source install/setup.bash && timeout 10 ros2 launch exo_sensors imu_csv_dev_wsl.launch.py 2>&1 | head -50
```

### 验证发布话题和频率
```bash
cd /workspace/robot_ws && source /opt/ros/humble/setup.bash && source install/setup.bash && timeout 15 bash -c "ros2 launch exo_sensors imu_csv_dev_wsl.launch.py &>/dev/null & sleep 3 && ros2 topic echo /imu/data --once && ros2 topic hz /imu/data --window 30"
```

**验证结果** ✅:
- 发布频率: **100.2-100.6 Hz** (目标100Hz)
- 数据格式: **sensor_msgs/Imu** 标准消息
- 加速度转换: **881mg → 8.62 m/s²**
- 角速度转换: **-0.26dps → -0.0045 rad/s**
- 姿态转换: **欧拉角 → 四元数 (w=0.911)**

---

## 🛠️ 完整系统启动（含记录和可视化）
```bash
ros2 launch exo_sensors imu_complete_system.launch.py \
    enable_recorder:=true \
    enable_visualizer:=true
```

数据保存位置: `robot_ws/src/exo_sensors/data/imu_data_YYYYMMDD_HHMMSS.csv`

---

## 📖 数据格式说明

### ESP32输出的CSV格式
```csv
Timestamp,Roll,Pitch,Yaw,AccX,AccY,AccZ,GyroX,GyroY,GyroZ
1545485,5.79,-2.54,-100.86,41.201,87.979,881.045,0.05,0.24,0.31
mg          ← 单位标记行（会被过滤）
dps         ← 单位标记行（会被过滤）
```

### ROS2发布的sensor_msgs/Imu
```yaml
linear_acceleration:   # m/s² (已从mg转换)
  x: 0.5046
  y: 0.9681
  z: 8.6161           # 约0.88g
angular_velocity:      # rad/s (已从dps转换)
  x: -0.0045
  y: 0.0062
  z: -0.0043
orientation:           # 四元数 (已从欧拉角转换)
  w: 0.9112
```

---

## ⚙️ 配置文件

### WSL2开发环境
`robot_ws/src/exo_sensors/config/imu_csv_dev_wsl.yaml`:
```yaml
serial_port: "/dev/ttyUSB0"  # 固定设备路径
baud_rate: 115200
auto_detect: false
```

### Raspberry Pi生产环境
`robot_ws/src/exo_sensors/config/imu_csv_raspberry_pi.yaml`:
```yaml
serial_port: "/dev/ttyUSB0"
baud_rate: 115200
auto_detect: true            # 自动检测CP210x/CH340
```

---

## 🔧 常见问题

### 问题: 找不到 /dev/ttyUSB0
```bash
# Windows端重新连接
usbipd attach --wsl --busid <BUSID>

# WSL端验证
lsusb | grep CP210
```

### 问题: 串口数据乱码
```bash
stty -F /dev/ttyUSB0 115200 cs8 -cstopb -parenb raw -echo
```

### 问题: 权限不足
```bash
sudo chmod 666 /dev/ttyUSB0
```

---

## 📚 参考文档
- **详细说明**: `robot_ws/src/exo_sensors/IMU_CSV_USAGE.md`
- **诊断脚本**: `robot_ws/check_esp32_serial.sh`
- **ESP32固件**: `sensor_source_code/9DOF_Demo_v2/9DOF_Demo_v2.ino`

---

# 输出的单位
让我详细解释这些单位和条件编译的含义: 

读取 [](file:///d%3A/1CodeProject/BUAA_BME_Training/sensor_source_code/9DOF_Demo_v3/QMI8658.cpp#1-1)，行 1 到 110

## 📊 单位含义和条件编译解释:

### 1️⃣ **加速度计单位切换**:

```cpp
#if defined(QMI8658_UINT_MG_DPS)
    // mg (毫重力加速度)
    acc[0] = (float)(raw_acc_xyz[0]*1000.0f)/g_imu.ssvt_a
#else
    // m/s² (米每二次方秒)
    acc[0] = (float)(raw_acc_xyz[0]*ONE_G)/g_imu.ssvt_a  // ONE_G = 9.807
#endif
```

**单位对比**:
- **`mg`** (毫重力): 1g = 1000mg，物理意义是地球重力加速度的千分之一
  - 例: 静止时 Z 轴约 1000mg (1g)
- **`m/s²`** (国际单位): 1g ≈ 9.807 m/s²
  - 例: 静止时 Z 轴约 9.807 m/s²

---

### 2️⃣ **陀螺仪单位切换**:

```cpp
#if defined(QMI8658_UINT_MG_DPS)
    // dps (度每秒)
    gyro[0] = (float)(raw_gyro_xyz[0]*1.0f)/g_imu.ssvt_g
#else
    // rad/s (弧度每秒)
    gyro[0] = (float)(raw_gyro_xyz[0]*M_PI)/(g_imu.ssvt_g*180)  // 转换为弧度
#endif
```

**单位对比**:
- **`dps`** (度每秒): 直观的角速度单位，360°/s = 转一圈每秒
  - 例: 快速转动可能达到 200-300 dps
- **`rad/s`** (弧度每秒): 国际单位，1 rad/s ≈ 57.3 dps
  - 例: 快速转动约 3.5-5.2 rad/s

---

### 3️⃣ **为什么用 `#if-else` 条件编译?**

这是 **编译期选择**,不是运行时判断:

```cpp
#define QMI8658_UINT_MG_DPS  // ← 第5行定义了这个宏
```

**原因**:
1. **避免运行时开销**: 编译时决定用哪套公式,运行时不需要 if 判断
2. **灵活切换单位**: 注释掉这一行就自动切换到国际单位制
3. **兼容不同应用**: 游戏控制用 dps 直观,机器人控制用 rad/s 标准

---

## 🎯 **你当前代码的实际单位**:

因为第 5 行定义了 `#define QMI8658_UINT_MG_DPS`,所以你的数据单位是:

| 数据字段 | 变量名 | 实际单位 | 物理含义 | 典型值范围 |
|---------|--------|---------|---------|-----------|
| **Roll/Pitch/Yaw** | `stAngles` | **度 (°)** | 欧拉角 | -180° ~ +180° |
| **AccX/Y/Z** | `stAccelRawData` | **mg** | 加速度(毫重力) | 静止约±1000mg |
| **GyroX/Y/Z** | `stGyroRawData` | **dps** | 角速度(度每秒) | 静止约±5dps |

---

## 📝 CSV 输出示例:

```csv
Timestamp,Roll,Pitch,Yaw,AccX,AccY,AccZ,GyroX,GyroY,GyroZ
1000,2.34°,-1.23°,89.45°,50mg,-30mg,1000mg,0.12dps,-0.45dps,0.23dps
```

**注意**: 你的 `snprintf` 格式化中:
- 加速度用 `%.3f` (3位小数) - 因为 mg 量级较大
- 陀螺仪用 `%.2f` (2位小数) - 因为 dps 通常个位数

---

## 💡 如果要切换到国际单位:

注释掉 QMI8658.cpp 第 5 行:
```cpp
// #define QMI8658_UINT_MG_DPS  // 注释掉
```

重新编译后,单位会变成:
- 加速度: **m/s²** (约 0.05 ~ 9.8)
- 陀螺仪: **rad/s** (约 0.002 ~ 5.2)

**但对于 SVM 步态识别,用 mg/dps 更合适!** 因为:
1. 数值范围更直观
2. 避免浮点精度损失(不需要乘 9.807 或 π)
3. 大多数 IMU 数据集也用这个单位