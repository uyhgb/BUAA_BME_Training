已规定所有的ttyUSB设备号

sudo nano /etc/udev/rules.d/99-robot.rules

# 1. 宇树电机 (FT232H) -> 绑定别名 /dev/unitree_motor
SUBSYSTEM=="tty", ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6014", MODE="0666", SYMLINK+="unitree_motor"

# 2. 足底传感器 (CH340) -> 绑定别名 /dev/foot_usb
SUBSYSTEM=="tty", ATTRS{idVendor}=="1a86", ATTRS{idProduct}=="7523", MODE="0666", SYMLINK+="foot_usb"

# 3. IMU (CP210x) -> 绑定别名 /dev/imu_usb
SUBSYSTEM=="tty", ATTRS{idVendor}=="10c4", ATTRS{idProduct}=="ea60", MODE="0666", SYMLINK+="imu_usb"

# 足底传感器的代码里写这个：
SERIAL_PORT = '/dev/foot_usb'

# IMU 的代码里写这个：
SERIAL_PORT = '/dev/imu_usb'

# 宇树电机的代码里写这个：
SERIAL_PORT = '/dev/unitree_motor'

TODO:还没有更新树莓派上的代码，以及USB设备号绑定，以及在wsl上的映射也没有修改












这是一个非常好的问题。理解这个机制对于做机器人系统集成至关重要，否则你的代码今天能跑，明天重启后可能就报错了。

简单来说，Linux 系统（树莓派 OS）分配 `ttyUSB0`、`ttyUSB1` 的顺序遵循一个核心原则：**“先到先得” (First Come, First Served)**。

具体分为两种情况：

### 1. 热插拔时（系统已经启动）

这是最直观的：

* 你先插入设备 A  系统分配 `/dev/ttyUSB0`
* 你再插入设备 B  系统分配 `/dev/ttyUSB1`
* 如果你拔掉 A，再插上 A  A 可能会变成 `/dev/ttyUSB2`（因为 0 和 1 刚才被占过，系统有时会顺延），或者变回 0（如果系统释放得快）。

### 2. 开机启动时（最坑的地方）

当你重启树莓派时，所有 USB 设备同时上电，这时候顺序由**“赛跑”**决定：

* **驱动加载速度：** 哪个设备的驱动先加载完？
* **硬件响应速度：** 哪个 USB 芯片初始化完成并先向 CPU "举手"？
* **USB 端口扫描顺序：** 树莓派的 USB 控制器通常按物理顺序扫描，但这并不绝对。

**结论：** 开机时的顺序是**随机的、不可预测的**。
今天 IMU 抢到了 `ttyUSB0`，明天可能足底传感器反应快抢到了 `ttyUSB0`。这就是为什么你之前的代码有时候能跑，有时候不能跑，或者连错设备。

---

### 解决方案：使用“身份证”而不是“排队号” (Udev Rules)

既然“排队号” (`ttyUSB*`) 不靠谱，我们需要给每个设备起一个**永远不变的别名**（比如 `/dev/imu` 和 `/dev/foot_sensor`）。

我们可以利用 **udev 规则**，根据设备的“电子身份证”（Vendor ID 和 Product ID）来绑定名字。

#### 步骤一：获取“身份证”信息

根据你之前的 `lsusb` 和手册信息，我们已经知道了它们的身份：

1. **IMU (CP210x):**
* `lsusb` 显示：`ID 10c4:ea60`
* Vendor ID (vid): `10c4`
* Product ID (pid): `ea60`


2. **足底传感器 (CH340):**
* 手册说是 CH340，通常 ID 是 `1a86:7523`。
* *为了保险，请你只插足底传感器时运行 `lsusb` 确认一下 ID。假设是 `1a86:7523`。*



#### 步骤二：创建固定规则

在终端运行以下命令，创建一个规则文件：

```bash
sudo nano /etc/udev/rules.d/99-robot-serial.rules

```

在编辑器里写入以下两行内容（**注意：如果不确定 CH340 的 ID，请先用 lsusb 确认**）：

```bash
# 绑定 IMU -> /dev/my_imu
SUBSYSTEM=="tty", ATTRS{idVendor}=="10c4", ATTRS{idProduct}=="ea60", MODE="0666", SYMLINK+="my_imu"

# 绑定 足底传感器 -> /dev/my_foot
# 注意：请核对下方的 idVendor 和 idProduct 是否与你的 lsusb 对应
SUBSYSTEM=="tty", ATTRS{idVendor}=="1a86", ATTRS{idProduct}=="7523", MODE="0666", SYMLINK+="my_foot"

```

*(解释：`MODE="0666"` 顺便解决了权限问题，以后不需要每次都 `sudo chmod` 了)*

按 `Ctrl+O` 保存，回车，再 `Ctrl+X` 退出。

#### 步骤三：生效并测试

1. **重新加载规则：**
```bash
sudo udevadm control --reload-rules && sudo udevadm trigger

```


2. **查看结果：**
此时，无论你的设备被分配成了 `ttyUSB0` 还是 `ttyUSB99`，你都应该能看到这两个固定的快捷方式：
```bash
ls -l /dev/my_*

```


输出应该类似：
> `lrwxrwxrwx 1 root root 7 ... /dev/my_imu -> ttyUSB0`
> `lrwxrwxrwx 1 root root 7 ... /dev/my_foot -> ttyUSB1`



#### 步骤四：修改代码

以后在 Python 代码里，永远不要写 `/dev/ttyUSB0`，而是写：

```python
# IMU 代码
SERIAL_PORT = '/dev/my_imu'

# 足底传感器代码
SERIAL_PORT = '/dev/my_foot'

```

这样，无论你插哪个口，无论怎么重启，代码永远找得到对的人！