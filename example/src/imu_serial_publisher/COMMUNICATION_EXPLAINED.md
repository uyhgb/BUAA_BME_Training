# IMU通信原理图解

## 🎯 核心问题: 为什么不能直接调用 `imuDataGet()`?

### 架构图

```
╔════════════════════════════════════════════════════════════════╗
║                     物理设备隔离                                 ║
╠════════════════════════════════════════════════════════════════╣
║                                                                ║
║  ┌────────────────────────┐          ┌──────────────────────┐ ║
║  │       ESP32            │          │      你的电脑         │ ║
║  │   (微控制器硬件)        │          │   (运行ROS2)         │ ║
║  │                        │          │                      │ ║
║  │  ┌──────────────────┐  │          │  ┌────────────────┐ │ ║
║  │  │  IMU传感器       │  │          │  │  ROS2节点      │ │ ║
║  │  │  ├─ 加速度计     │  │          │  │                │ │ ║
║  │  │  ├─ 陀螺仪       │  │          │  │  订阅者可以    │ ║
║  │  │  └─ (磁力计)     │  │          │  │  接收/imu/data │ │ ║
║  │  └──────────────────┘  │          │  └────────────────┘ │ ║
║  │           ↓             │          │          ↑          │ ║
║  │  ┌──────────────────┐  │          │  ┌────────────────┐ │ ║
║  │  │ imuDataGet()     │  │          │  │ 串口读取+解析  │ │ ║
║  │  │ (C++函数)        │  │          │  │ readAndPublish │ │ ║
║  │  └──────────────────┘  │          │  └────────────────┘ │ ║
║  │           ↓             │          │          ↑          │ ║
║  │  ┌──────────────────┐  │   USB    │  ┌────────────────┐ │ ║
║  │  │ JSON编码         │  │  串口线   │  │ JSON解析       │ │ ║
║  │  │ ArduinoJson      │  │ ◄──────► │  │ nlohmann/json  │ │ ║
║  │  └──────────────────┘  │          │  └────────────────┘ │ ║
║  │           ↓             │          │          ↑          │ ║
║  │  Serial.println()      │══════════│  Serial.read()       │ ║
║  └────────────────────────┘          └──────────────────────┘ ║
║                                                                ║
╚════════════════════════════════════════════════════════════════╝
```

## 📊 数据流向

### 1️⃣ ESP32端 (数据采集)
```cpp
// 运行在ESP32微控制器上
void loop() {
    // ① 读取硬件传感器
    imuDataGet(&angles, &gyro, &accel, &magn);
    
    // ② 编码为JSON字符串
    {"orientation": {"roll": 1.2, ...}, ...}
    
    // ③ 通过串口发送
    Serial.println(json_string);  // → 发送到USB
}
```

### 2️⃣ 串口传输 (物理通信)
```
ESP32 UART TX ──[USB转换]──→ 电脑 /dev/ttyUSB0
    (文本流)                    (字符流)
```

### 3️⃣ 电脑端 (ROS2发布)
```cpp
// 运行在你的电脑上
void readAndPublish() {
    // ① 从串口读取文本
    string line = readLine();  // 读取: {"orientation":...}
    
    // ② 解析JSON
    auto j = json::parse(line);
    
    // ③ 提取数据并填充ROS消息
    imu_msg.orientation.x = ...;
    imu_msg.angular_velocity.x = j["gyroscope"]["x"];
    
    // ④ 发布到ROS话题
    imu_pub_->publish(imu_msg);  // → /imu/data
}
```

## ❓ 常见误解

### ❌ 错误理解
```cpp
// 这是不可能的!
// ROS2节点在电脑上,不能直接调用ESP32上的函数
auto data = imuDataGet();  // ❌ 跨设备调用不存在
```

### ✅ 正确理解
```
ESP32上:  imuDataGet() → 获取数据 → JSON编码 → 串口发送
                                                ↓
电脑上:                            串口接收 ← JSON解析 ← ROS2发布
```

## 🔧 为什么选择JSON?

### 对比其他方案

| 方案 | 优点 | 缺点 | 适用场景 |
|-----|------|------|---------|
| **JSON** | 人类可读、易调试、跨平台 | 稍占带宽 | ✅ 开发调试、通用通信 |
| 二进制协议 | 高效、省带宽 | 难调试、需定义格式 | 高频数据、生产环境 |
| CSV | 简单 | 缺乏结构、不支持嵌套 | 简单数据记录 |
| ROS串行 | ROS原生 | 需要额外库、复杂 | ROS专用设备 |

### JSON示例
```json
{
  "orientation": {"roll": 1.23, "pitch": -0.45, "yaw": 90.3},
  "acceleration": {"x": 0.05, "y": -0.02, "z": 9.81},
  "gyroscope": {"x": 0.001, "y": -0.003, "z": 0.002},
  "timestamp": 123456
}
```

**特点**:
- 字段名明确 (不会搞混xyz)
- 易于扩展 (添加字段不影响兼容性)
- 调试方便 (串口监视器直接看懂)

## 🎓 类比理解

把ESP32和电脑想象成两个人:

```
ESP32 (小明):                     电脑 (小红):
"我测量到加速度是9.81"          "收到!记录下来"
      ↓                               ↑
  [对讲机发送] ══════════════════ [对讲机接收]
      JSON = 说的语言
      串口 = 对讲机信道
```

- **不能心灵感应** (不能直接调用对方的函数)
- **必须说话交流** (通过串口发送数据)
- **要用共同语言** (JSON格式)

## 📝 总结

1. **ESP32和电脑是独立设备** → 不能直接函数调用
2. **串口是通信桥梁** → 只能传输字节流
3. **JSON是数据格式** → 将结构化数据编码为文本
4. **ROS2节点是接收端** → 解析数据并发布到话题

这个设计让ESP32专注于硬件控制,电脑专注于数据处理,各司其职!
